import ssvc, json, os, sys, aiohttp, asyncio
from .report import *


# Function that calculates the exploitability of a CVE
async def exploitability(session, semaphore, VulnerabilityID): 
    year = VulnerabilityID[4:8]
    url = f"https://github.com/trickest/cve/blob/main/{year}/{VulnerabilityID}.md"

    async with semaphore:
        try:
            async with session.get(url) as response:
                print(f"Analyzing {VulnerabilityID}")
                if response.status == 404:
                    exploit_calc = 'none'
                else:
                    exploit_calc = 'poc'
        except aiohttp.ClientError as e:
            print(f"Error during the request: {e}")
            exploit_calc = 'none'

    return exploit_calc


# Function that calculates the automatability of a CVE
def automatibility(V3Vector):

    try:
        ui = V3Vector[27]

        if(ui == 'N'):
            automation_calc = 'yes'
        else:
            automation_calc = 'no'
        
        return automation_calc
    except Exception as e:
        print(f"An error occurred while calculating the automatibility of a CVE: {str(e)}")
        sys.exit(-1)

# Function that calculates the technical impact of a CVE
def technical_impact(V3Vector):

    try:
        confidentiality = V3Vector[35]
        integrity = V3Vector[39]
        availability = V3Vector[43]

        impact_values = {
            "H": 0.56,
            "L": 0.22,
            "N": 0.0
        }

        confidentiality_value = impact_values.get(confidentiality, 0.0)
        integrity_value = impact_values.get(integrity, 0.0)
        availability_value = impact_values.get(availability, 0.0)

        # Impact Sub-Score
        iss = 1 - ((1 - confidentiality_value) * (1 - integrity_value) * (1 - availability_value))

        # threshold for the ISS
        threshold = 0.67

        if (iss > threshold):
            ti_calc = 'total'
        else:
            ti_calc = 'partial'

        return ti_calc
    except Exception as e:
        print(f"An error occurred while calculating the technical impact of a CVE: {str(e)}")
        sys.exit(-1)


# Function that calculates the mission well-being of a CVE
def mission_wellbeing(V3Vector):

    # Mission prevalence (minimal, support, essential): relevance of the vulnerable object within the project, default = essential (highest level)
    mp = "essential" 
    # Public well-being impact (minimal, material, irreversible): impact of compromised systems on humans, default = irreversible (highest level)
    pwbi = "irreversible"

    mw_calc = 'high'

    # If a method to calculate mp and pwbi is implemented, uncomment the following part

    # if (pwbi == "irreversible"):
    #     mw_calc = 'high'
    # elif (pwbi == "material" and mp in ["minimal", "support"]):
    #     mw_calc = 'medium'
    # elif (pwbi == "minimal"):
    #     mw_calc = 'low' if (mp == "minimal") else 'medium'
    # else:
    #     mw_calc = 'high'

    return mw_calc


# Function that calculates the weight to be assigned to each CVE
async def calcolo_peso(session, semaphore, V3Vector, VulnerabilityID):
    try:
        exploit = await exploitability(session, semaphore, VulnerabilityID)

        decision = ssvc.Decision(
            exploitation=exploit,                           # none, poc, (active)   --> from trickest on github
            automatable=automatibility(V3Vector),           # yes, no               --> from V3Vector, human interaction field
            technical_impact=technical_impact(V3Vector),    # partial, total        --> from V3Vector, Confidentiality, Integrity, Availability fields
            mission_wellbeing=mission_wellbeing(V3Vector),  # low, medium, high     --> default is high
        )

        outcome = decision.evaluate()
        outcome_cutted = str(outcome.action)[11:]
        
        match outcome_cutted:
            case "TRACK":
                peso = 0
            case "TRACK_STAR":
                peso = 1
            case "ATTEND":
                peso = 2
            case "ACT":
                peso = 3
            case _:
                print("Error, weight set to maximum for precaution")
                peso = 3
        
        return peso
    except Exception as e:
        print(f"An error occurred while calculating the weight of a CVE: {str(e)}")
        sys.exit(-1)


# Function that extracts CVEs and their information from the JSON generated by Trivy image
def estrai_CVE_da_JSON_Trivy_image(json_file):
    try:
        vulnerabilities_dict = {}

        with open(json_file, 'r') as file:
            data = json.load(file)

        for result in data['Results']:
            if 'Vulnerabilities' in result:
                for vulnerability in result['Vulnerabilities']:
                    vulnerability_id = vulnerability.get('VulnerabilityID', '')
                    
                    if vulnerability_id not in vulnerabilities_dict:
                        title = vulnerability.get('Title', '')
                        description = vulnerability.get('Description', '')
                        severity = vulnerability.get('Severity', '')

                        if 'redhat' in vulnerability.get('CVSS', {}):
                            redhat_cvss = vulnerability['CVSS']['redhat']
                            v3vector = redhat_cvss.get('V3Vector', '')
                            v3score = redhat_cvss.get('V3Score', '')
                        else:
                            v3vector = vulnerability.get('CVSS', {}).get('nvd', {}).get('V3Vector', '')
                            v3score = vulnerability.get('CVSS', {}).get('nvd', {}).get('V3Score', '')

                        # Default values if previous ones are not present
                        v3vector = v3vector if v3vector else '-1'
                        v3score = v3score if v3score else '-1'

                        # Add the dictionary to the vulnerabilities dictionary
                        vulnerabilities_dict[vulnerability_id] = {
                            'VulnerabilityID': vulnerability_id,
                            'Title': title,
                            'Description': description,
                            'Severity': severity,
                            'V3Vector': v3vector,
                            'V3Score': v3score
                        }
            
        return list(vulnerabilities_dict.values())
    except Exception as e:
        print(f"An error occurred while extracting CVEs from Trivy image JSON: {str(e)}")
        sys.exit(-1)


# Function that analyzes CVE information and calculates the weight
async def analisi_CVE(vulnerabilities_list):
    try:
        new_vulnerabilities_list = []
        semaphore = asyncio.Semaphore(4) #limit simultaneous connections
        async with aiohttp.ClientSession() as session:
            tasks = []
            for vulnerability in vulnerabilities_list:
                if vulnerability['V3Vector'] != "-1" and vulnerability['V3Score'] != "-1":
                    tasks.append(calcolo_peso(session, semaphore, vulnerability['V3Vector'], vulnerability['VulnerabilityID']))
                else:
                    tasks.append(asyncio.sleep(0, result=0))

            pesi = await asyncio.gather(*tasks)

            for vulnerability, peso in zip(vulnerabilities_list, pesi):
                vulnerability['Peso'] = peso
                new_vulnerabilities_list.append(vulnerability)
            print("\nCVE analysis completed\n")  

        return new_vulnerabilities_list
    except Exception as e:
        print(f"An error occurred while analyzing CVEs: {str(e)}")
        sys.exit(-1)


# Function that combines the previous functions, sorts by descending weight and prepares the text to print
def ordina_prepara_trivy_image(json_file):

    try: 
        peso3 = 0
        peso2 = 0
        peso1 = 0
        peso0 = 0
        vulnerabilities_list = estrai_CVE_da_JSON_Trivy_image(json_file)
        if vulnerabilities_list:
            vulnerabilities_list_peso = asyncio.run(analisi_CVE(vulnerabilities_list))
            #Descending sorting by weight
            vulnerabilities_list_sorted = sorted(vulnerabilities_list_peso, key=lambda x: x['Peso'], reverse=True)
            #text for the report
            testo = f"\nThe analyzed image was found to be potentially vulnerable to {len(vulnerabilities_list_sorted)} CVEs. They are sorted in descending order of weight [max=3, min=0], a calculated parameter that estimates the relevance of the CVE and indicates how urgent it is to take mitigation actions.\n\n-------------------"
            for vulnerability in vulnerabilities_list_sorted:
                match vulnerability['Peso']:
                    case 3:
                        peso = "3 - Act immediately"
                        peso3 += 1
                    case 2:
                        peso = "2 - Monitor and plan the intervention"
                        peso2 += 1
                    case 1:
                        peso = "1 - Monitor the vulnerability"
                        peso1 += 1
                    case 0:
                        peso = "0 - Situation under control"
                        peso0 += 1
                image_file = make_graph(peso3, peso2, peso1, peso0)
                testo += f"\nVulnerabilityID: {vulnerability['VulnerabilityID']}\n"
                testo += f"Title: {vulnerability['Title']}\n"
                testo += f"Peso: {peso}\n"
                testo += "-------------------"       
        else:
            testo = "\nThe image was not found to be vulnerable to any CVEs."

        return testo, image_file
    except Exception as e:
        print(f"An error occurred while assigning the weight to the CVEs: {str(e)}")
        sys.exit(-1)


# Function that extracts the image name from the JSON generated by docker inspect
def estrai_da_JSON_Docker_inspect(json_file):
    
    try:
        with open(json_file, 'r') as file:
            data = json.load(file)

        if 'RepoTags' in data[0]:
            repotags = data[0]['RepoTags'][0].replace("[","").replace("]","")
        else:
            repotags = "ERROR"

        return repotags
    except Exception as e:
        print(f"An error occurred while extracting the name of the analyzed image: {str(e)}")
        sys.exit(-1)

# Function that extracts any issues detected in the JSON produced by Trivy fs
def estrai_da_JSON_trivy_fs(json_file):

    with open(json_file, 'r') as file:
        data = json.load(file)

    if 'Title' in data:
        testo = f"Here are the main issues detected by Trivy:\n{estrai_titoli(data, testo)}"
    else:
        testo = "No issues were detected in this analysis"
    return testo


# Function that extracts titles from a JSON content recursively
def estrai_titoli(data, testo):
    
    try:
        if isinstance(data, dict):
            for key, value in data.items():
                if key == 'Title':
                    testo += f"- {value}\n"
                else:
                    testo = estrai_titoli(value, testo)
        elif isinstance(data, list):
            for element in data:
                testo = estrai_titoli(element, testo)
            
        return testo
    except Exception as e:
        print(f"An error occurred while extracting titles from the JSON: {str(e)}")
        sys.exit(-1)
        

# Function that extracts any issues detected from the txt produced by Semgrep
def estrai_da_semgrep(txt_file):

    try:
        titoli = []

        with open(txt_file, 'r') as file:
            if (os.path.getsize(txt_file) == 0):
                testo = "No issues were detected in this analysis"
            else:
                testo = "Here are the main issues detected:\n"
                for line in file:
                    line = line.strip()
                    if line.startswith('❯❯❱'):
                        titolo = line[4:]
                    elif line.startswith('❯❱'):
                        titolo = line[3:]
                    elif line.startswith('❯'):
                        titolo = line[1:]
                    elif line.startswith('❱'):
                        titolo = line[1:]
                    else:
                        continue

                    titolo = titolo.replace('.', ' ').replace('-', ' ')
                    if titolo not in titoli:
                        titoli.append(titolo)
                        testo += f"- {titolo}\n"
                    
        return testo
    except Exception as e:
        print(f"An error occurred while extracting from Semgrep: {str(e)}")
        sys.exit(-1)


# Function that extracts the number of issues from Docker Bench for Security
def estrai_da_dockerbenchsec(txt_file):

    try:
        with open(txt_file, 'r') as file:
            content = file.read()
        warn_count = content.count("[WARN]")
        if (warn_count == 0):
            testo = "No issues were detected in the Docker configuration"
        else:
            testo = f"{warn_count} issues were detected in the Docker configuration.\nCheck the file for entries with WARN and compare with the CIS Docker Benchmark v1.6.0"

        return testo
    except Exception as e:
        print(f"An error occurred while extracting the number of issues from Docker Bench for Security: {str(e)}")
        sys.exit(-1)
